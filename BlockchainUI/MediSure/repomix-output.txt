This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-01T12:50:55.005Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
commands.txt
contracts/MedicineSupplyChain.sol
migrations/2_deploy_contracts.js
package.json
test/medicineSupplyChain.test.js
truffle-config.js

================================================================
Files
================================================================

================
File: commands.txt
================
1.Compile the contract:
truffle compile

2.Deploy to Ganache:
truffle migrate --network development

3.Run the tests using the Truffle test command:
truffle test

4.Or to run only this specific test file:
truffle test ./test/medicineSupplyChain.test.jsProject  

5.Open Truffle console:
truffle console --network development


6.Use Truffle Console for Testing
We can use the Truffle console to interact with your contract directly:

// Get contract instance
let instance = await MedicineSupplyChain.deployed()

// Get accounts
let accounts = await web3.eth.getAccounts()

// Add a medicine (from manufacturer account)
let manufacturingDate = Math.floor(new Date('2025-01-01').getTime() / 1000)
let expiryDate = Math.floor(new Date('2027-01-01').getTime() / 1000)
await instance.addMedicine("Paracetamol", "Acetaminophen 500mg", manufacturingDate, expiryDate, {from: accounts[0]})

// Check medicine counter
let count = await instance.medicineCounter()
count.toString()

// Get medicine details
let details = await instance.getMedicineDetails(1)
details

// Sell to retailer
await instance.sellMedicineToRetailer(1, accounts[1], {from: accounts[0]})

// Sell to buyer
await instance.sellMedicineToBuyer(1, accounts[2], {from: accounts[1]})

// Check if medicine is expired
let isExpired = await instance.isMedicineExpired(1)
isExpired

================
File: contracts/MedicineSupplyChain.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract MedicineSupplyChain {
    // Structure to store medicine information
    struct Medicine {
        uint256 id;
        string name;
        string composition;
        uint256 manufacturingDate;
        uint256 expiryDate;
        address manufacturer;
        address retailer;
        address buyer;
        bool isSoldToRetailer;
        bool isSoldToBuyer;
    }

    // Mapping to store medicines by their ID
    mapping(uint256 => Medicine) public medicines;

    // Counter for medicine IDs
    uint256 public medicineCounter;

    // Events to emit important actions
    event MedicineAdded(uint256 indexed medicineId, string name, address indexed manufacturer);
    event MedicineSoldToRetailer(uint256 indexed medicineId, address indexed retailer);
    event MedicineSoldToBuyer(uint256 indexed medicineId, address indexed buyer);

    // Modifiers to restrict access
    modifier onlyManufacturer(uint256 medicineId) {
        require(medicines[medicineId].manufacturer == msg.sender, "Only the manufacturer can perform this action.");
        _;
    }

    modifier onlyRetailer(uint256 medicineId) {
        require(medicines[medicineId].retailer == msg.sender, "Only the retailer can perform this action.");
        _;
    }

    modifier onlyBuyer(uint256 medicineId) {
        require(medicines[medicineId].buyer == msg.sender, "Only the buyer can perform this action.");
        _;
    }

    modifier medicineNotSoldToRetailer(uint256 medicineId) {
        require(!medicines[medicineId].isSoldToRetailer, "Medicine already sold to a retailer.");
        _;
    }

    modifier medicineNotSoldToBuyer(uint256 medicineId) {
        require(!medicines[medicineId].isSoldToBuyer, "Medicine already sold to a buyer.");
        _;
    }

    // Manufacturer adds a new medicine to the blockchain
    function addMedicine(
        string memory _name,
        string memory _composition,
        uint256 _manufacturingDate,
        uint256 _expiryDate
    ) public {
        require(_expiryDate > _manufacturingDate, "Expiry date should be after the manufacturing date.");

        medicineCounter++;
        medicines[medicineCounter] = Medicine(
            medicineCounter,
            _name,
            _composition,
            _manufacturingDate,
            _expiryDate,
            msg.sender, // Manufacturer address
            address(0), // Retailer address (initially 0)
            address(0), // Buyer address (initially 0)
            false, // isSoldToRetailer flag
            false  // isSoldToBuyer flag
        );

        emit MedicineAdded(medicineCounter, _name, msg.sender);
    }

    // Manufacturer sells medicine to a retailer
    function sellMedicineToRetailer(uint256 _medicineId, address _retailer)
        public
        onlyManufacturer(_medicineId)
        medicineNotSoldToRetailer(_medicineId)
    {
        medicines[_medicineId].retailer = _retailer;
        medicines[_medicineId].isSoldToRetailer = true;

        emit MedicineSoldToRetailer(_medicineId, _retailer);
    }

    // Retailer sells medicine to a buyer
    function sellMedicineToBuyer(uint256 _medicineId, address _buyer)
        public
        onlyRetailer(_medicineId)
        medicineNotSoldToBuyer(_medicineId)
    {
        medicines[_medicineId].buyer = _buyer;
        medicines[_medicineId].isSoldToBuyer = true;

        emit MedicineSoldToBuyer(_medicineId, _buyer);
    }

    // Buyer retrieves information about a purchased medicine
    function getMedicineDetails(uint256 _medicineId)
        public
        view
        returns (
            string memory name,
            string memory composition,
            uint256 manufacturingDate,
            uint256 expiryDate,
            address manufacturer,
            address retailer,
            address buyer
        )
    {
        Medicine memory medicine = medicines[_medicineId];
        return (
            medicine.name,
            medicine.composition,
            medicine.manufacturingDate,
            medicine.expiryDate,
            medicine.manufacturer,
            medicine.retailer,
            medicine.buyer
        );
    }

    // Function to check if the medicine is expired
    function isMedicineExpired(uint256 _medicineId) public view returns (bool) {
        return block.timestamp > medicines[_medicineId].expiryDate;
    }
}

================
File: migrations/2_deploy_contracts.js
================
const MedicineSupplyChain = artifacts.require("MedicineSupplyChain");

module.exports = function (deployer) {
  deployer.deploy(MedicineSupplyChain);
};

================
File: package.json
================
{
  "name": "project-1",
  "version": "1.0.0",
  "description": "",
  "main": "truffle-config.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@openzeppelin/contracts": "^5.2.0"
  }
}

================
File: test/medicineSupplyChain.test.js
================
const MedicineSupplyChain = artifacts.require("MedicineSupplyChain");

contract("MedicineSupplyChain", (accounts) => {
  const manufacturer = accounts[0];
  const retailer = accounts[1];
  const buyer = accounts[2];
  const unauthorized = accounts[3];

  let medicineSupplyChainInstance;
  let currentTime;
  let manufacturingDate;
  let expiryDate;
  let expiredDate;

  beforeEach(async () => {
    medicineSupplyChainInstance = await MedicineSupplyChain.new({ from: manufacturer });
    currentTime = Math.floor(Date.now() / 1000);
    manufacturingDate = currentTime - 86400; // 1 day ago
    expiryDate = currentTime + 31536000; // 1 year in the future
    expiredDate = currentTime - 86400; // 1 day ago (already expired)
  });

  describe("Medicine Addition", () => {
    it("should allow a manufacturer to add a medicine", async () => {
      await medicineSupplyChainInstance.addMedicine(
        "Paracetamol",
        "Acetaminophen 500mg",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );

      const medicineCounter = await medicineSupplyChainInstance.medicineCounter();
      assert.equal(medicineCounter, 1, "Medicine counter should be incremented");

      const medicineDetails = await medicineSupplyChainInstance.getMedicineDetails(1);
      assert.equal(medicineDetails.name, "Paracetamol", "Medicine name should match");
      assert.equal(medicineDetails.composition, "Acetaminophen 500mg", "Medicine composition should match");
      assert.equal(medicineDetails.manufacturer, manufacturer, "Manufacturer address should match");
    });

    it("should not allow adding medicine with expiry date before manufacturing date", async () => {
      try {
        await medicineSupplyChainInstance.addMedicine(
          "Invalid Medicine",
          "Invalid Composition",
          expiryDate, // Using future date as manufacturing date
          manufacturingDate, // Using past date as expiry date
          { from: manufacturer }
        );
        assert.fail("The transaction should have thrown an error");
      } catch (err) {
        assert.include(err.message, "revert", "The error message should contain 'revert'");
        assert.include(err.message, "Expiry date should be after the manufacturing date", "Should revert with appropriate message");
      }
    });
  });

  describe("Retailer Operations", () => {
    beforeEach(async () => {
      await medicineSupplyChainInstance.addMedicine(
        "Paracetamol",
        "Acetaminophen 500mg",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );
    });

    it("should allow a manufacturer to sell medicine to a retailer", async () => {
      await medicineSupplyChainInstance.sellMedicineToRetailer(1, retailer, { from: manufacturer });

      const medicineDetails = await medicineSupplyChainInstance.getMedicineDetails(1);
      assert.equal(medicineDetails.retailer, retailer, "Retailer address should match");

      const medicine = await medicineSupplyChainInstance.medicines(1);
      assert.equal(medicine.isSoldToRetailer, true, "Medicine should be marked as sold to retailer");
    });

    it("should not allow non-manufacturer to sell medicine to retailer", async () => {
      try {
        await medicineSupplyChainInstance.sellMedicineToRetailer(1, retailer, { from: unauthorized });
        assert.fail("The transaction should have thrown an error");
      } catch (err) {
        assert.include(err.message, "revert", "The error message should contain 'revert'");
        assert.include(err.message, "Only the manufacturer can perform this action", "Should revert with appropriate message");
      }
    });

    it("should not allow selling medicine to retailer multiple times", async () => {
      await medicineSupplyChainInstance.sellMedicineToRetailer(1, retailer, { from: manufacturer });

      try {
        await medicineSupplyChainInstance.sellMedicineToRetailer(1, accounts[4], { from: manufacturer });
        assert.fail("The transaction should have thrown an error");
      } catch (err) {
        assert.include(err.message, "revert", "The error message should contain 'revert'");
        assert.include(err.message, "Medicine already sold to a retailer", "Should revert with appropriate message");
      }
    });
  });

  describe("Buyer Operations", () => {
    beforeEach(async () => {
      await medicineSupplyChainInstance.addMedicine(
        "Paracetamol",
        "Acetaminophen 500mg",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );
      await medicineSupplyChainInstance.sellMedicineToRetailer(1, retailer, { from: manufacturer });
    });

    it("should allow a retailer to sell medicine to a buyer", async () => {
      await medicineSupplyChainInstance.sellMedicineToBuyer(1, buyer, { from: retailer });

      const medicineDetails = await medicineSupplyChainInstance.getMedicineDetails(1);
      assert.equal(medicineDetails.buyer, buyer, "Buyer address should match");

      const medicine = await medicineSupplyChainInstance.medicines(1);
      assert.equal(medicine.isSoldToBuyer, true, "Medicine should be marked as sold to buyer");
    });

    it("should not allow non-retailer to sell medicine to buyer", async () => {
      try {
        await medicineSupplyChainInstance.sellMedicineToBuyer(1, buyer, { from: unauthorized });
        assert.fail("The transaction should have thrown an error");
      } catch (err) {
        assert.include(err.message, "revert", "The error message should contain 'revert'");
        assert.include(err.message, "Only the retailer can perform this action", "Should revert with appropriate message");
      }
    });

    it("should not allow selling medicine to buyer multiple times", async () => {
      await medicineSupplyChainInstance.sellMedicineToBuyer(1, buyer, { from: retailer });

      try {
        await medicineSupplyChainInstance.sellMedicineToBuyer(1, accounts[4], { from: retailer });
        assert.fail("The transaction should have thrown an error");
      } catch (err) {
        assert.include(err.message, "revert", "The error message should contain 'revert'");
        assert.include(err.message, "Medicine already sold to a buyer", "Should revert with appropriate message");
      }
    });
  });

  describe("Medicine Expiry", () => {
    it("should correctly identify expired medicine", async () => {
        // Ensure the expiry date is AFTER the manufacturing date but still in the past
        let pastExpiryDate = manufacturingDate + 100; // Slightly after manufacturing date
      
        await medicineSupplyChainInstance.addMedicine(
          "ExpiredMedicine",
          "Expired Compound",
          manufacturingDate,
          pastExpiryDate,
          { from: manufacturer }
        );
      
        const isExpired = await medicineSupplyChainInstance.isMedicineExpired(1);
        assert.equal(isExpired, true, "Medicine should be marked as expired");
      });

    it("should correctly identify non-expired medicine", async () => {
      // Add non-expired medicine
      await medicineSupplyChainInstance.addMedicine(
        "ValidMedicine",
        "Valid Compound",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );

      const isExpired = await medicineSupplyChainInstance.isMedicineExpired(1);
      assert.equal(isExpired, false, "Medicine should not be marked as expired");
    });
  });

  describe("Medicine Details", () => {
    beforeEach(async () => {
      await medicineSupplyChainInstance.addMedicine(
        "Paracetamol",
        "Acetaminophen 500mg",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );
      await medicineSupplyChainInstance.sellMedicineToRetailer(1, retailer, { from: manufacturer });
      await medicineSupplyChainInstance.sellMedicineToBuyer(1, buyer, { from: retailer });
    });

    it("should provide complete medicine details", async () => {
      const details = await medicineSupplyChainInstance.getMedicineDetails(1);
      
      assert.equal(details.name, "Paracetamol", "Medicine name should match");
      assert.equal(details.composition, "Acetaminophen 500mg", "Medicine composition should match");
      assert.equal(details.manufacturingDate.toNumber(), manufacturingDate, "Manufacturing date should match");
      assert.equal(details.expiryDate.toNumber(), expiryDate, "Expiry date should match");
      assert.equal(details.manufacturer, manufacturer, "Manufacturer address should match");
      assert.equal(details.retailer, retailer, "Retailer address should match");
      assert.equal(details.buyer, buyer, "Buyer address should match");
    });
  });

  describe("Multiple Medicines", () => {
    it("should handle multiple medicines correctly", async () => {
      // Add first medicine
      await medicineSupplyChainInstance.addMedicine(
        "Paracetamol",
        "Acetaminophen 500mg",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );

      // Add second medicine
      await medicineSupplyChainInstance.addMedicine(
        "Ibuprofen",
        "Ibuprofen 400mg",
        manufacturingDate,
        expiryDate,
        { from: manufacturer }
      );

      // Check counter
      const medicineCounter = await medicineSupplyChainInstance.medicineCounter();
      assert.equal(medicineCounter, 2, "Medicine counter should be incremented to 2");

      // Check details of first medicine
      const details1 = await medicineSupplyChainInstance.getMedicineDetails(1);
      assert.equal(details1.name, "Paracetamol", "First medicine name should match");

      // Check details of second medicine
      const details2 = await medicineSupplyChainInstance.getMedicineDetails(2);
      assert.equal(details2.name, "Ibuprofen", "Second medicine name should match");
    });
  });
});

================
File: truffle-config.js
================
module.exports = {
  networks: {
    development: {
      host: "127.0.0.1",
      port: 8545, // Default Ganache port
      network_id: "*", // Match any network id
    },
  },
  compilers: {
    solc: {
      version: "0.8.19", // Match your contract's pragma
      settings: {
        optimizer: {
          enabled: true,
          runs: 200,
        },
      },
    },
  },
};
